[TOC]

## 1.向量基础知识

### [NIST Handbook of Mathematical Functions](D:\0work\学习资料\math\NIST Handbook of Mathematical Functions.pdf)**1.6 Vectors and Vector-Valued Functions** P26/967

### [Handbook of Mathematics](D:\0work\学习资料\math\Handbook of Mathematics.pdf)**3 Geometry **P173/1255

## 2.语法糖P591/1866

### [ISO-IEC 14882-2020(1)](D:\0work\学习资料\code\ISO-IEC 14882-2020(1).pdf)**20 General utilities library** 

## 3.数据竞争p93/1866

### **[ISO-IEC 14882-2020(1)](D:\0work\学习资料\code\ISO-IEC 14882-2020(1).pdf)6.9.2 Multi-threaded executions and data races** 

**数据竞争（Data Race）**是并发编程中的一种现象，它发生在多个线程试图同时访问同一块共享数据时，如果至少有一个线程对数据进行写操作，而这些访问操作没有适当的同步机制来协调它们。数据竞争可能导致程序的不可预测行为、错误结果，甚至崩溃。因此，理解和避免数据竞争是多线程编程中的关键。

### 数据竞争的具体条件

数据竞争通常满足以下几个条件：
1. **多个线程**：至少有两个线程在并行执行。
2. **共享数据**：这些线程访问同一块共享的内存数据。
3. **并发访问**：线程之间的访问没有进行适当的同步或协调。
4. **至少一个线程进行写操作**：如果所有线程都是只读的，即使是并发访问，也不会引发数据竞争，但如果有线程进行写操作且没有同步保护，那么就会出现数据竞争。

### 数据竞争的影响
数据竞争的影响可能是不可预测的，因为多个线程可能以不同的顺序执行它们的操作，这就导致：
- **数据不一致**：共享数据可能处于不可预知的状态，导致结果错误。
- **程序崩溃**：竞争条件可能会导致程序崩溃，尤其是在一些低级系统操作中。
- **调试困难**：数据竞争往往是随机发生的，因此调试和重现非常困难。

### 示例
假设两个线程在没有同步机制的情况下同时访问共享变量 `x`：

```cpp
int x = 0;

void thread1() {
    x = 1;
}

void thread2() {
    x = 2;
}
```

在这个例子中，`thread1` 和 `thread2` 都在修改全局变量 `x`，但没有进行同步。由于这两个线程可能并发执行，最终 `x` 的值可能是 `1` 或 `2`，具体取决于哪一个线程最后执行写操作。更糟糕的是，线程可能会交替地读取和写入，这会使得 `x` 处于一种中间状态，导致程序行为不可预期。

### 如何避免数据竞争

为了避免数据竞争，可以使用以下几种技术：

1. **互斥锁（Mutex）**：使用互斥锁确保只有一个线程可以在某一时刻访问共享数据。线程在进入临界区（对共享数据进行操作的代码段）之前获取锁，退出临界区时释放锁。其他线程必须等待锁被释放后才能进入临界区。
   
   示例：

   ```cpp
   int x = 0;
   std::mutex mtx;

   void thread1() {
       mtx.lock();
       x = 1;
       mtx.unlock();
   }

   void thread2() {
       mtx.lock();
       x = 2;
       mtx.unlock();
   }
   ```

2. **原子操作（Atomic Operations）**：原子操作确保某个操作在多个线程之间不可分割地执行。C++ 提供了 `std::atomic` 类型来进行原子操作。

   示例：

   ```cpp
   std::atomic<int> x(0);

   void thread1() {
       x.store(1);  // 原子写操作
   }

   void thread2() {
       x.store(2);  // 原子写操作
   }
   ```

3. **条件变量（Condition Variable）**：条件变量与互斥锁配合使用，用于线程之间的同步。线程可以通过条件变量等待特定条件满足后再继续执行。

4. **读写锁（Read-Write Lock）**：当多个线程读取共享数据时，可以使用读写锁，这样多个线程可以同时读取，而只有一个线程能够写入。

5. **内存屏障（Memory Barriers）**：内存屏障是底层硬件机制，用来防止编译器和处理器对内存操作的重排序，从而避免数据竞争。

### 数据竞争 vs 竞态条件

**数据竞争**是**竞态条件（Race Condition）**的一种特殊情况。竞态条件指的是程序的结果依赖于线程执行的顺序，数据竞争是指多个线程同时访问共享数据时没有正确同步导致的竞态条件。

### 数据竞争的检测工具
由于数据竞争难以发现，开发者可以使用一些工具来帮助检测：
- **ThreadSanitizer (TSan)**：这是一个用于检测 C/C++ 程序中数据竞争的静态分析工具，集成在 Clang 和 GCC 编译器中。
- **Helgrind**：Valgrind 的一个工具，用于检测多线程程序中的数据竞争。
- **Race Condition Detector**：许多 IDE 和调试工具也提供竞态条件和数据竞争的检测功能。

### 总结

数据竞争是多线程编程中的一个常见问题，会导致程序的不可预测行为。通过使用同步机制（如互斥锁、原子操作等）来控制对共享数据的访问，可以有效避免数据竞争。

## 4.前进进度

**Forward progress**（前进进度）是计算机科学、尤其是在多线程或并行编程中使用的术语。它描述了程序执行过程中，线程或进程能够持续推进而不会永久停滞或死锁的特性。简单来说，**forward progress** 意味着某个线程或进程一定会在有限的时间内继续执行并完成它的任务，而不会无限期地等待或被阻止。

在并发编程中，**forward progress** 是一个重要的概念，用来保证程序中的每个线程都能够有效工作，不会因为资源竞争或调度问题而停滞不前。根据不同的系统和编程模型，forward progress 有不同的级别和保证。

### 主要的 **forward progress** 模型包括：

1. **Obstruction-free**（无阻塞）
   - 保证：只要没有其他线程阻碍当前线程，它就会取得进展。
   - 含义：一个线程只会因为其他线程的干扰而暂时停下，如果没有其他线程干扰，它将继续执行。
   - 例子：乐观并发控制技术，例如无锁数据结构。

2. **Lock-free**（无锁）
   - 保证：即使多个线程争用资源，系统也保证至少有一个线程能够持续取得进展。
   - 含义：虽然不是每个线程都能保证持续进展，但至少有一个线程不会停滞。

3. **Wait-free**（无等待）
   - 保证：每个线程在有限的步数内都能完成操作，不会因为其他线程的影响而无限等待。
   - 含义：所有线程都有强进度保证，能够独立于其他线程执行并完成任务。

### 为什么 forward progress 很重要？
在多线程或并行程序中，如果不能保证 forward progress，程序可能会遇到**死锁**、**活锁**、或者无限等待等问题，导致整个系统无法正常完成任务。forward progress 提供了程序在并发执行时能持续向前推进的保障。

### 举个例子：
假设有两个线程在访问共享资源，如果没有 forward progress 的保障，可能会发生一种情况：
- 线程 A 持有资源 1，正在等待资源 2；
- 线程 B 持有资源 2，正在等待资源 1；
这时两个线程都在等待对方释放资源，结果两个线程都停滞不前，出现了**死锁**。

如果系统有 forward progress 的某种机制，它会保证至少有一个线程能在有限的时间内获得资源，打破死锁局面，使程序继续运行。

### 总结：
**Forward progress** 是指在多线程或并行程序中，线程或进程能够在有限时间内继续推进和执行的特性。它有助于防止程序死锁、活锁或无限期等待，并通过不同的进度模型（无阻塞、无锁、无等待）提供不同层次的保证。