[TOC]

### 2.examples

![image-20240313095017043](D:\0work\学习资料\readme\add\2.examples.assets\image-20240313095017043.png)

#### main函数

```c++
#include <QApplication>
#include <QMainWindow>
#include "myvtkapp.h"

int main(int argc, char** argv)
{
    QApplication a(argc, argv);

    MyVTKApp w;
    w.show();

    return a.exec();
}
```

#### ball类

##### h

```c++
//ball类
// ball.h
#ifndef BALL_H
#define BALL_H

#include <vtkSphereSource.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>

class Ball
{
public:
    Ball(double radius = 0.5);

    vtkSmartPointer<vtkActor> getActor() const;

private:
    vtkSmartPointer<vtkSphereSource> sphereSource;
    vtkSmartPointer<vtkPolyDataMapper> mapper;
    vtkSmartPointer<vtkActor> actor;
};

#endif // BALL_H

```
##### cpp
```c++
// ball.cpp
#include "ball.h"

Ball::Ball(double radius)
{
    //数据
    sphereSource = vtkSmartPointer<vtkSphereSource>::New();
    sphereSource->SetRadius(radius);

    //映射器
    mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    mapper->SetInputConnection(sphereSource->GetOutputPort());

    //可视化对象
    actor = vtkSmartPointer<vtkActor>::New();
    actor->SetMapper(mapper);
}

vtkSmartPointer<vtkActor> Ball::getActor() const
{
    return actor;
}

```

#### myVTKApp
##### h
```c++
//myvtkapp.h
#ifndef MYVTKAPP_H
#define MYVTKAPP_H

#include <QWidget>
#include <vtkRenderer.h>

// #include <vtkGenericOpenGLRenderWindow.h>
// #include <vtkRenderWindowInteractor.h>
// #include <vtkSphereSource.h>
// #include <vtkPolyDataMapper.h>
// #include <vtkActor.h>
// #include <vtkInteractorStyleTrackballCamera.h>
#include <vtkProperty.h>
#include <QVTKOpenGLStereoWidget.h>
#include "ball.h"

namespace Ui {
class MyVTKApp;
}

struct RenderWidget;

class MyVTKApp : public QWidget
{
    Q_OBJECT

public:
    explicit MyVTKApp(QWidget *parent = nullptr);
    ~MyVTKApp();

private:
    void create_ball();

    Ui::MyVTKApp *ui;
    std::shared_ptr<RenderWidget> vtk_window;
    std::shared_ptr<Ball> ball;

};

#endif // MYVTKAPP_H

```
##### cpp
```c++
#include <QVTKOpenGLStereoWidget.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkOrientationMarkerWidget.h>
#include <vtkAxesActor.h>
#include <vtkRenderer.h>
#include <vtkCamera.h>

#include "myvtkapp.h"
#include "ui_myvtkapp.h"

struct RenderWidget : QVTKOpenGLStereoWidget
{
    RenderWidget()
    {
        // 创建VTK渲染器
        render = vtkSmartPointer<vtkRenderer>::New();

        // 创建VTK渲染窗口
        renWin = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();

        //将渲染器绑定到渲染窗口
        renWin->AddRenderer(render);

        // background灰色
        render->SetBackground(0.3, 0.3, 0.3);
        //启用FXAA抗锯齿
        render->UseFXAAOn();

        // `setRenderWindow`是 `QVTKOpenGLStereoWidget` 类中的一个成员函数，
        //用于将一个 VTK 渲染窗口与 `QVTKOpenGLStereoWidget` 相关联
        setRenderWindow(renWin.Get());
        // 在这里，vtkGenericOpenGLRenderWindow是一个VTK中的渲染窗口类。
        // renWin.Get() 获取了vtkGenericOpenGLRenderWindow的原始指针，它是一个指向vtkGenericOpenGLRenderWindow对象的指针。

        // 这行代码的作用是将一个VTK渲染窗口与RenderWidget类的对象相关联，以便在RenderWidget中显示VTK渲染结果。
        // 这样，RenderWidget就能够在Qt应用程序中嵌入VTK渲染窗口，并显示VTK场景。


        // 坐标系
        auto interactor = renWin->GetInteractor();
        auto axes = vtkSmartPointer<vtkAxesActor>::New();
        marker = vtkSmartPointer<vtkOrientationMarkerWidget>::New();
        marker->SetOrientationMarker(axes);
        marker->SetInteractor(interactor);
        marker->SetEnabled(1);
        marker->InteractiveOff();
    }

    void do_render()
    {
        renWin->Render();
    }

    vtkSmartPointer<vtkRenderer> get_render()
    {
        return render;
    }

    void remove_actor(std::vector<vtkSmartPointer<vtkProp>> &actor)
    {
        for (auto &a : actor) {
            render->RemoveActor(a);
        }
    }

    void add_actor(std::vector<vtkSmartPointer<vtkProp>> &actor)
    {
        for (auto &a : actor) {
            render->AddActor(a);
        }
    }

    void set_project_perspective(double dim_ref)
    {
        auto camera = render->GetActiveCamera();
        double distance_focal = 600;
        camera->ParallelProjectionOff();
        camera->SetFocalPoint(0, 0, 0);
        camera->SetClippingRange(1, 1200);
        camera->SetPosition(0, 0, distance_focal);
        camera->SetViewUp(0, 1, 0);
        camera->Elevation(45);
        camera->Azimuth(30);
        if (dim_ref <= std::numeric_limits<double>::epsilon()) {
            return;
        }
        auto view_angle = std::atan(dim_ref / distance_focal) / M_PI * 180 * 2;
        camera->SetViewAngle(view_angle);
    }

    void set_project_orthographic(std::string d, double dim_ref)
    {
        auto camera = render->GetActiveCamera();
        camera->ParallelProjectionOn();
        camera->SetFocalPoint(0, 0, 0);
        camera->SetClippingRange(1, 1200);
        if ("XY" == d) {
            camera->SetPosition(0, 0, 600);
            camera->SetViewUp(0, 1, 0);
        } else if ("ZX" == d) {
            camera->SetPosition(0, 600, 0);
            camera->SetViewUp(0, 0, -1);
        } else if ("YZ" == d) {
            camera->SetPosition(600, 0, 0);
            camera->SetViewUp(0, 1, 0);
        } else {
            // no case,
        }
        if (std::fabs(dim_ref_prev - dim_ref) < std::numeric_limits<double>::epsilon()) {
            return;
        }
        if (dim_ref <= std::numeric_limits<double>::epsilon()) {
            return;
        }
        camera->SetParallelScale(dim_ref);
        dim_ref_prev = dim_ref;
    }

private:
    vtkSmartPointer<vtkGenericOpenGLRenderWindow> renWin;
    vtkSmartPointer<vtkRenderer> render;
    vtkSmartPointer<vtkOrientationMarkerWidget> marker;

private:
    double dim_ref_prev = 0;
};


MyVTKApp::MyVTKApp(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MyVTKApp)
{
    ui->setupUi(this);

    vtk_window = std::make_shared<RenderWidget>();
    ui->vtk_layout->addWidget(vtk_window.get());

    create_ball();
}

//2024年3月13日13:01:36 版本2
//不能自适应
std::shared_ptr<Ball> init__ball(double r)
{
    auto b = std::make_shared<Ball>(r);
    return b;
}
void MyVTKApp::create_ball()
{
    auto r = ui->r->value();

    //如果存在,渲染窗口移除旧的对象
    if(ball)
    {
        vtk_window->get_render()->RemoveActor(ball.get()->getActor());
    }
    // 创建球体
    ball = init__ball(r);

    // 设置vtkActor的属性
    auto actor = ball.get()->getActor();
    actor->GetProperty()->SetColor(1.0, 0.0, 0.0);  // 红色
    actor->GetProperty()->SetOpacity(1.0);  // 不透明

    // 获取球体的vtkActor，并将其添加到渲染器中
    vtk_window->get_render()->AddActor(actor);
    vtk_window->do_render();
}

void MyVTKApp::on_r_editingFinished()
{
    create_ball();
}

/*  2024年3月12日  版本1
  	手动创建球对象
  	待修改:ui->r需要添加槽函数,editingFinished()
  		  添加一个std::shared_ptr<Ball>对象,传参数进来
void MyVTKApp::create_ball()
{
    auto r = ui->r->value();
    // auto b = Ball(r);

    // 创建球体
    Ball myBall(0.5); // 指定球体半径

    // 设置vtkActor的属性
    auto actor = myBall.getActor();
    actor->GetProperty()->SetColor(1.0, 0.0, 0.0);  // 红色
    actor->GetProperty()->SetOpacity(1.0);  // 不透明

    // 获取球体的vtkActor，并将其添加到渲染器中
    vtk_window->get_render()->AddActor(actor);
    vtk_window->do_render();
}*/

MyVTKApp::~MyVTKApp()
{
    delete ui;
}

```

#### 界面

![image-20240313094927991](D:\0work\学习资料\readme\add\2.examples.assets\image-20240313094927991.png)