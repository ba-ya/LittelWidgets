---

### ✅ 你的问题：`O(log n)` 是以 2 为底吗？

**答案：是的，在分析红黑树等平衡二叉搜索树时，`O(log n)` 通常指的是以 2 为底的对数 `log₂n`。**

但注意：
- 在 **大 O 表示法**中，`O(log₂n)`、`O(log₁₀n)`、`O(ln n)` 都写作 `O(log n)`，因为它们只差一个常数倍，**在渐进分析中是等价的**。
- 所以我们说 `O(log n)`，隐含的就是 `log₂n`，尤其是在树结构中。

---

## ✅ 各 STL 容器时间复杂度完整总结

| 容器                              | 底层结构                     | 随机访问                   | 插入/删除（某位置）                 | 查找                     | 构造/清空                      |
| --------------------------------- | ---------------------------- | -------------------------- | ----------------------------------- | ------------------------ | ------------------------------ |
| `std::vector`                     | 连续数组                     | ✅ `O(1)`                   | ❌ 尾部 `O(1)`，中间/头部 `O(n)`     | `O(n)`                   | 构造 `O(n)`，清空 `O(n)`       |
| `std::deque`                      | 分段连续数组                 | ✅ `O(1)`                   | ✅ 首尾 `O(1)`，中间 `O(n)`          | `O(n)`                   | 构造 `O(n)`，清空 `O(n)`       |
| `std::list` / `std::forward_list` | 双向/单向链表                | ❌ `O(n)`                   | ✅ 任意位置 `O(1)`（已知位置）       | `O(n)`                   | 构造 `O(n)`，清空 `O(n)`       |
| `std::stack`                      | 适配器（默认 `deque`）       | ❌                          | ❌ 仅支持 `top/push/pop`             | ❌                        | `O(1)` 操作                    |
| `std::queue`                      | 适配器（默认 `deque`）       | ❌                          | ❌ 仅支持 `front/back/push/pop`      | ❌                        | `O(1)` 操作                    |
| `std::priority_queue`             | 适配器（默认 `vector` + 堆） | ❌                          | ❌ `push: O(log n)`, `pop: O(log n)` | ❌                        | `O(n)`                         |
| `std::set` / `std::multiset`      | 红黑树（自平衡二叉搜索树）   | ✅ 节点访问 `O(log n)`      | `O(log n)`                          | `O(log n)`               | 构造 `O(n log n)`，清空 `O(n)` |
| `std::map` / `std::multimap`      | 红黑树                       | ✅ 节点访问 `O(log n)`      | `O(log n)`                          | `O(log n)`               | 构造 `O(n log n)`，清空 `O(n)` |
| `std::unordered_set`              | 哈希表（Hash Table）         | ✅ 平均 `O(1)`，最坏 `O(n)` | 平均 `O(1)`，最坏 `O(n)`            | 平均 `O(1)`，最坏 `O(n)` | 构造 `O(n)`，清空 `O(n)`       |
| `std::unordered_map`              | 哈希表                       | ✅ 平均 `O(1)`，最坏 `O(n)` | 平均 `O(1)`，最坏 `O(n)`            | 平均 `O(1)`，最坏 `O(n)` | 构造 `O(n)`，清空 `O(n)`       |

---

### 🔍 详细说明

#### 1. `vector`
- **随机访问**：`operator[]` 和 `at()` 都是 `O(1)`
- **尾部插入**：`push_back()` 平均 `O(1)`（偶尔扩容 `O(n)`）
- **中间插入**：需要移动元素，`O(n)`
- **查找**：必须遍历，`O(n)`

#### 2. `deque`
- **随机访问**：`O(1)`，但比 `vector` 稍慢（分段寻址）
- **首尾插入**：`O(1)`，是 `deque` 的优势
- **中间插入**：`O(n)`
- **适用场景**：需要频繁在首尾增删的场景

#### 3. `list`
- **随机访问**：不支持，`O(n)` 遍历
- **插入/删除**：**已知位置**（迭代器）时是 `O(1)`，非常高效
- **查找**：`O(n)`
- **优点**：插入不导致迭代器失效

#### 4. `stack` / `queue`
- 都是**容器适配器**，不支持随机访问
- 所有操作都是 `O(1)`
- `stack`: `push`, `pop`, `top`
- `queue`: `push`, `pop`, `front`, `back`

#### 5. `set` / `map`
- 基于**红黑树**，自动排序，唯一键（`set`）或键值对（`map`）
- 所有操作：`O(log₂n)`^up^ ~down~
- 迭代器是有序的（中序遍历）

#### 6. `unordered_set` / `unordered_map`（你写的 `hash_set` 是旧名）
- 基于**哈希表**
- **平均情况**：`O(1)`
- **最坏情况**：哈希冲突严重时退化为 `O(n)`（链表过长）
- **不排序**，键的顺序不确定
- **需要哈希函数**（`std::hash`）

---

### ✅ 总结对比表（按性能）

| 操作                         | 最快容器                                        |
| ---------------------------- | ----------------------------------------------- |
| **随机访问**                 | `vector`, `deque`                               |
| **头部插入**                 | `deque`, `list`                                 |
| **尾部插入**                 | `vector`, `deque`                               |
| **任意位置插入（已知位置）** | `list`                                          |
| **查找（已知值）**           | `unordered_set`, `unordered_map`（平均 `O(1)`） |
| **有序查找/遍历**            | `set`, `map`（`O(log n)`）                      |
| **最小/最大值查询**          | `priority_queue`（堆）                          |

---

### 🎯 最后建议

- 需要**快速查找**？用 `unordered_set` / `unordered_map`
- 需要**自动排序**？用 `set` / `map`
- 需要**频繁在中间插入**？用 `list`
- 需要**随机访问 + 尾部操作**？用 `vector`
- 需要**首尾都高效操作**？用 `deque`
- 需要**栈/队列语义**？用 `stack` / `queue`

掌握这些时间复杂度，你就能写出高性能的 C++ 程序了！💪