---

### 一、先明确：C++ 只有两种参数传递方式

1. **值传递（Pass by Value）**
2. **引用传递（Pass by Reference）**

> ✅ C++ **没有**所谓的“指针传递”作为独立的传递机制。  
> “指针传参”只是**值传递的一种特例**。

---

### 二、关键理解：传递的是“什么”

我们来看一个例子：

```cpp
void func(int *p) {
    p = nullptr;  // 只修改了 p 的副本
}

int main() {
    int a = 10;
    int *ptr = &a;
    func(ptr);
    // 问：ptr 现在是 nullptr 吗？
    return 0;
}
```

答案是：**不是！`ptr` 仍然指向 `&a`**。

#### 为什么？

- 调用 `func(ptr)` 时，系统**复制了 `ptr` 的值**（也就是 `&a` 这个地址）。
- 函数内部的 `p` 是 `ptr` 的一个**副本**，它和 `ptr` 指向同一块内存，但 `p` 本身是一个独立的变量。
- 所以你在 `func` 里修改 `p`（比如 `p = nullptr`），只会影响副本，不会影响外面的 `ptr`。

👉 **这正是“值传递”的定义：传递的是值的副本，函数内部无法修改实参本身。**

---

### 三、对比三种情况

| 传参方式               | 代码示例           | 能否修改指针本身？ | 能否修改指针指向的数据？ |
| ---------------------- | ------------------ | ------------------ | ------------------------ |
| **值传递（指针）**     | `void f(int *p)`   | ❌ 不能             | ✅ 能（通过 `*p`）        |
| **引用传递（指针）**   | `void f(int * &p)` | ✅ 能               | ✅ 能                     |
| **值传递（普通变量）** | `void f(int a)`    | N/A                | ❌ 不能                   |

#### 例子 1：指针的值传递（你问的情况）

```cpp
void func(int *p) {
    p = nullptr;  // 只改副本
}
// 外面的 ptr 不变
```

#### 例子 2：指针的引用传递（真正的“指针传参”）

```cpp
void func(int * &p) {  // p 是 ptr 的别名
    p = nullptr;  // 修改的是原始指针
}

int *ptr = &a;
func(ptr);
// 此时 ptr == nullptr！
```

> ✅ 只有加了 `&`，才是真正的“引用传递”，才能修改指针本身。

---

### 四、类比理解 🌰

想象你有一把钥匙（指针 `ptr`）可以打开一扇门（变量 `a`）。

- **值传递（指针）**：你复制了一把钥匙（`p`）给别人。  
  - 别人可以用这把钥匙开门改东西（修改 `*p`）。
  - 但如果你把复制的钥匙弄断了（`p = nullptr`），你的原钥匙（`ptr`）还是好好的。

- **引用传递（指针）**：你把原钥匙借出去了（`int* &p`）。  
  - 对方可以直接弄断你的钥匙（`p = nullptr`），你就再也打不开门了。

---

### 五、为什么大家都说“指针传参”？

- “指针传参”是一个**习惯性说法**，强调的是“参数是指针类型”。
- 它的重点是：**可以通过指针修改所指向的数据**。
- 但从**语言机制**上讲，它仍然是**值传递**，因为指针变量本身是被复制的。

---

### ✅ 总结

| 问题                           | 回答                                                     |
| ------------------------------ | -------------------------------------------------------- |
| **指针传参是值传递吗？**       | ✅ 是！传递的是指针的值（地址），是值传递的一种。         |
| **为什么不算“指针传递”？**     | ❌ C++ 没有“指针传递”这种机制。只有“值传递”和“引用传递”。 |
| **如何才能真正传递指针本身？** | 使用 `int* &p`，即指针的引用。                           |
| **指针传参能改数据吗？**       | ✅ 能改它指向的数据（`*p`），但不能改指针本身（`p`）。    |

> 🎯 **一句话总结**：  
> “**指针传参**” 是**值传递**，传递的是**地址的副本**；  
> 只有 `类型*&` 才是**引用传递**，才能真正修改指针本身。
